{"version":1,"ops":[{"type":6,"author":{"id":"37314acb12deef6cac38223490bc1b720908d897"},"timestamp":1616244479,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdElzc3VlRWRpdDo1MTA5NTE1Mjg="},"target":"74032b06e4c3d7eaf8e3063f522b7e939d35ac3a180e904115b1d56235745ca3","message":"This has much in common the problem of `repo.process`.\nThere the problem is, that `repo.process` is too complicated(= not that easy to port),\nbecause there is no trivial way to get the list of all repos, without the command itself.\nYes it is easy, but it is not trivial.\nA trivial solution should be like parsing a CSV or at least similar.","files":null},{"type":6,"author":{"id":"37314acb12deef6cac38223490bc1b720908d897"},"timestamp":1616375989,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdElzc3VlRWRpdDo1MTEyMTYwNDM="},"target":"74032b06e4c3d7eaf8e3063f522b7e939d35ac3a180e904115b1d56235745ca3","message":"This has much in common the problem of `repo.process`.\nThere the problem is, that `repo.process` is too complicated(= not that easy to port),\nbecause there is no trivial way to get the list of all repos, without the command itself.\nYes it is easy, but it is not trivial.\nA trivial solution should be like parsing a CSV or at least similar.\n\nComing back to the problem at hand.\nWe need a simply model, how the website server works.\n\n- [ ] Thereby, the objectives updated.\n- [ ] Also a model needs to documented.\n\n- [ ] The website servers main task should be to project multiple projects as one.\nIt works like overlayfs, except that each project has also multiple layers.\n- [ ] The layered result is than projected via renderers to a different folder.\n\n- [ ] A pipeline of such renderers is possible.\n- [ ] The chosen renderers determine the properties of the results.\nThis way the website can be renderer to any medium.\n\n- [ ] This overlay and rendering system should be so simple, that a minimal implementation might as well be\nwritten in bash.\n\n- [ ] Explicitly support the usage of the website server in a setting, where the server is part of a foreign rendering pipeline.","files":null},{"type":6,"author":{"id":"37314acb12deef6cac38223490bc1b720908d897"},"timestamp":1616376953,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdElzc3VlRWRpdDo1MTEyMjE1MjU="},"target":"74032b06e4c3d7eaf8e3063f522b7e939d35ac3a180e904115b1d56235745ca3","message":"This has much in common the problem of `repo.process`.\nThere the problem is, that `repo.process` is too complicated(= not that easy to port),\nbecause there is no trivial way to get the list of all repos, without the command itself.\nYes it is easy, but it is not trivial.\nA trivial solution should be like parsing a CSV or at least similar.\n\nComing back to the problem at hand.\nWe need a simply model, how the website server works.\n\n- [ ] Thereby, the objectives updated.\n- [ ] Also a model needs to documented.\n\n- [ ] The website servers main task should be to project multiple projects as one.\nIt works like overlayfs, except that each project has also multiple layers.\n- [ ] The layered result is than projected via renderers to a different folder.\n\n- [ ] A pipeline of such renderers is possible.\n- [ ] The chosen renderers determine the properties of the results.\nThis way the website can be renderer to any medium.\n\n- [ ] This overlay and rendering system should be so simple, that a minimal implementation might as well be\nwritten in bash.\n\n- [ ] Explicitly support the usage of the website server in a setting, where the server is part of a foreign rendering pipeline.\n- [ ] Renderers should be seen as something which adds something and does not change/delete something.\nIn the best case, the website is serviceable without any additional renderers.\nIn this case the reading quality would of course be severely inconsistent, because it would be like reading \nthe source code of the website directly.\nThis would work great for common mark files, but it would not be as great for i.e. MathML files.","files":null},{"type":6,"author":{"id":"37314acb12deef6cac38223490bc1b720908d897"},"timestamp":1617362777,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdElzc3VlRWRpdDo1MTc1MzMxMTI="},"target":"74032b06e4c3d7eaf8e3063f522b7e939d35ac3a180e904115b1d56235745ca3","message":"This has much in common the problem of `repo.process`.\nThere the problem is, that `repo.process` is too complicated(= not that easy to port),\nbecause there is no trivial way to get the list of all repos, without the command itself.\nYes it is easy, but it is not trivial.\nA trivial solution should be like parsing a CSV or at least similar.\n\nComing back to the problem at hand.\nWe need a simply model, how the website server works.\n\n- [ ] Thereby, the objectives need to be updated.\n- [ ] Also a rendering model needs to documented.\n\n- [ ] The website servers main task should be to project multiple projects as one.\nIt works like overlayfs, except that each project has also multiple layers.\n- [ ] The layered result is than projected via renderers to a different folder.\n\n- [ ] A pipeline of such renderers is possible.\n- [ ] The chosen renderers determine the properties of the results.\nThis way the website can be renderer to any medium.\n\n- [ ] This overlay and rendering system should be so simple, that a minimal implementation might as well be\nwritten in bash.\n\n- [ ] Explicitly support the usage of the website server in a setting, where the server is part of a foreign rendering pipeline.\n- [ ] Renderers should be seen as something which adds something and does not change/delete something.\nIn the best case, the website is serviceable without any additional renderers.\nIn this case the reading quality would of course be severely inconsistent, because it would be like reading \nthe source code of the website directly.\nThis would work great for common mark files, but it would not be as great for i.e. MathML files.","files":null},{"type":6,"author":{"id":"37314acb12deef6cac38223490bc1b720908d897"},"timestamp":1628763238,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdElzc3VlRWRpdDo1ODc0NDM1OTE="},"target":"74032b06e4c3d7eaf8e3063f522b7e939d35ac3a180e904115b1d56235745ca3","message":"This has much in common the problem of `repo.process`.\nThere the problem is, that `repo.process` is too complicated(= not that easy to port),\nbecause there is no trivial way to get the list of all repos, without the command itself.\nYes it is easy, but it is not trivial.\nA trivial solution should be like parsing a CSV or at least similar.\n\nComing back to the problem at hand.\nWe need a simply model, how the website server works.\n\n- [ ] Thereby, the objectives need to be updated.\n- [ ] Also a rendering model needs to documented.\n\n- [ ] The website servers main task should be to project multiple projects as one.\nIt works like overlayfs, except that each project has also multiple layers.\n- [ ] The layered result is than projected via renderers to a different folder.\n\n- [ ] A pipeline of such renderers is possible.\n- [ ] The chosen renderers determine the properties of the results.\nThis way the website can be renderer to any medium.\n\n- [ ] This overlay and rendering system should be so simple, that a minimal implementation might as well be\nwritten in bash.\n\n- [ ] Explicitly support the usage of the website server in a setting, where the server is part of a foreign rendering pipeline.\n- [ ] Renderers should be seen as something which adds something and does not change/delete something.\nIn the best case, the website is serviceable without any additional renderers.\nIn this case the reading quality would of course be severely inconsistent, because it would be like reading \nthe source code of the website directly.\nThis would work great for common mark files, but it would not be as great for i.e. MathML files.\n\n- [ ] Maybe support gitbook as a renderer.","files":null},{"type":6,"author":{"id":"37314acb12deef6cac38223490bc1b720908d897"},"timestamp":1630193211,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdElzc3VlRWRpdDo1OTYzNDE5NzM="},"target":"74032b06e4c3d7eaf8e3063f522b7e939d35ac3a180e904115b1d56235745ca3","message":"This has much in common the problem of `repo.process`.\nThere the problem is, that `repo.process` is too complicated(= not that easy to port),\nbecause there is no trivial way to get the list of all repos, without the command itself.\nYes it is easy, but it is not trivial.\nA trivial solution should be like parsing a CSV or at least similar.\n\nComing back to the problem at hand.\nWe need a simply model, how the website server works.\n\n- [x] Thereby, the objectives need to be updated.\n- [ ] Define layered plugin based rendering system based on shell and file system as universal interface,\nthat model a rendering pipeline.\n- [ ] This rendering system should be so simple, that a minimal implementation might as well be\nwritten in bash.\nProvide an simple example implementation\n- [ ] Rendering pipeline should be functional/side effect free.\n- [ ] Render website to gemini.","files":null},{"type":6,"author":{"id":"37314acb12deef6cac38223490bc1b720908d897"},"timestamp":1630261555,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdElzc3VlRWRpdDo1OTY0NzM1ODM="},"target":"74032b06e4c3d7eaf8e3063f522b7e939d35ac3a180e904115b1d56235745ca3","message":"This has much in common the problem of `repo.process`.\nThere the problem is, that `repo.process` is too complicated(= not that easy to port),\nbecause there is no trivial way to get the list of all repos, without the command itself.\nYes it is easy, but it is not trivial.\nA trivial solution should be like parsing a CSV or at least similar.\n\nComing back to the problem at hand.\nWe need a simply model, how the website server works.\n\n- [x] Thereby, the objectives need to be updated.\n- [ ] Define layered plugin based rendering system based on shell and file system as universal interface,\nthat model a rendering pipeline.\nMake a system overview of this system via a data flow like chart.\n- [ ] This rendering system should be so simple, that a minimal implementation might as well be\nwritten in bash.\nProvide an simple example implementation\n- [ ] Rendering pipeline should be functional/side effect free.\n- [ ] Render website to gemini.","files":null},{"type":6,"author":{"id":"37314acb12deef6cac38223490bc1b720908d897"},"timestamp":1630261578,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdElzc3VlRWRpdDo1OTY0NzM2MTQ="},"target":"74032b06e4c3d7eaf8e3063f522b7e939d35ac3a180e904115b1d56235745ca3","message":"This has much in common the problem of `repo.process`.\nThere the problem is, that `repo.process` is too complicated(= not that easy to port),\nbecause there is no trivial way to get the list of all repos, without the command itself.\nYes it is easy, but it is not trivial.\nA trivial solution should be like parsing a CSV or at least similar.\n\nComing back to the problem at hand.\nWe need a simply model, how the website server works.\n\n- [x] Thereby, the objectives need to be updated.\n- [ ] Define layered plugin based rendering system based on shell and file system as universal interface,\nthat model a rendering pipeline.\nMake a system overview of this system via a data flow like diagram.\n- [ ] This rendering system should be so simple, that a minimal implementation might as well be\nwritten in bash.\nProvide an simple example implementation\n- [ ] Rendering pipeline should be functional/side effect free.\n- [ ] Render website to gemini.","files":null},{"type":6,"author":{"id":"37314acb12deef6cac38223490bc1b720908d897"},"timestamp":1630805303,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdElzc3VlRWRpdDo2MDA3ODMwNTQ="},"target":"74032b06e4c3d7eaf8e3063f522b7e939d35ac3a180e904115b1d56235745ca3","message":"This has much in common the problem of `repo.process`.\nThere the problem is, that `repo.process` is too complicated(= not that easy to port),\nbecause there is no trivial way to get the list of all repos, without the command itself.\nYes it is easy, but it is not trivial.\nA trivial solution should be like parsing a CSV or at least similar.\n\nComing back to the problem at hand.\nWe need a simply model, how the website server works.\n\n- [x] Thereby, the objectives need to be updated.\n- [ ] Define layered plugin based rendering system based on shell and file system as universal interface,\nthat model a rendering pipeline.\nMake a system overview of this system via a data flow like diagram.\n- [ ] This rendering system should be so simple, that a minimal implementation might as well be\nwritten in bash.\nProvide an simple example implementation\n- [ ] Rendering pipeline should be functional/side effect free.\n- [ ] Render website to gemini.\n\nPlugin system based on dependency injection:\n```\nrenderer[i] -\u003e output[i] // How to chain renderers?\noutput[1...n] -\u003e merge -\u003e output-2\n```","files":null},{"type":6,"author":{"id":"37314acb12deef6cac38223490bc1b720908d897"},"timestamp":1633131831,"metadata":{"github-id":"UCE_lAHOFCNQW84x4IfKziTN6wE"},"target":"74032b06e4c3d7eaf8e3063f522b7e939d35ac3a180e904115b1d56235745ca3","message":"This has much in common the problem of `repo.process`.\nThere the problem is, that `repo.process` is too complicated(= not that easy to port),\nbecause there is no trivial way to get the list of all repos, without the command itself.\nYes it is easy, but it is not trivial.\nA trivial solution should be like parsing a CSV or at least similar.\n\nComing back to the problem at hand.\nWe need a simply model, how the website server works.\n\n- [x] Thereby, the objectives need to be updated.\n- [x] Create a dedicated project defining a standard for supporting arbitrary renderers. -\u003e `net.splitcells.website.server.interface`\n- [ ] Define layered plugin based rendering system based on shell and file system as universal interface,\nthat model a rendering pipeline.\nMake a system overview of this system via a data flow like diagram.\n- [ ] This rendering system should be so simple, that a minimal implementation might as well be\nwritten in bash.\nProvide an simple example implementation\n- [ ] Rendering pipeline should be functional/side effect free.\n- [ ] Render website to gemini.\n\nPlugin system based on dependency injection:\n```\nrenderer[i] -\u003e output[i] // How to chain renderers?\noutput[1...n] -\u003e merge -\u003e output-2\n```","files":null},{"type":6,"author":{"id":"37314acb12deef6cac38223490bc1b720908d897"},"timestamp":1633132357,"metadata":{"github-id":"UCE_lAHOFCNQW84x4IfKziTN8ys"},"target":"74032b06e4c3d7eaf8e3063f522b7e939d35ac3a180e904115b1d56235745ca3","message":"This has much in common the problem of `repo.process`.\nThere the problem is, that `repo.process` is too complicated(= not that easy to port),\nbecause there is no trivial way to get the list of all repos, without the command itself.\nYes it is easy, but it is not trivial.\nA trivial solution should be like parsing a CSV or at least similar.\n\nComing back to the problem at hand.\nWe need a simply model, how the website server works.\n\n- [x] Thereby, the objectives need to be updated.\n- [x] Create a dedicated project defining a standard for supporting arbitrary renderers. -\u003e `net.splitcells.website.server.interface`\n- [ ] Define layered plugin based rendering system based on shell and file system as universal interface,\nthat model a rendering pipeline.\nMake a system overview of this system via a data flow like diagram.\n- [ ] This rendering system should be so simple, that a minimal implementation might as well be\nwritten in bash.\nProvide an simple example implementation\n- [ ] Rendering pipeline should be functional/side effect free.\n- [ ] Combine standard website with network's blog.\n\nPlugin system based on dependency injection:\n```\nrenderer[i] -\u003e output[i] // How to chain renderers?\noutput[1...n] -\u003e merge -\u003e output-2\n```","files":null},{"type":6,"author":{"id":"37314acb12deef6cac38223490bc1b720908d897"},"timestamp":1633135402,"metadata":{"github-id":"UCE_lAHOFCNQW84x4IfKziTOHnQ"},"target":"74032b06e4c3d7eaf8e3063f522b7e939d35ac3a180e904115b1d56235745ca3","message":"This has much in common the problem of `repo.process`.\nThere the problem is, that `repo.process` is too complicated(= not that easy to port),\nbecause there is no trivial way to get the list of all repos, without the command itself.\nYes it is easy, but it is not trivial.\nA trivial solution should be like parsing a CSV or at least similar.\n\nComing back to the problem at hand.\nWe need a simply model, how the website server works.\n\n- [x] Thereby, the objectives need to be updated.\n- [x] Create a dedicated project defining a standard for supporting arbitrary renderers. -\u003e `net.splitcells.website.server.interface`\n- [x] Define layered plugin based rendering system based on shell and file system as universal interface,\nthat model a rendering pipeline.\n- [ ] Make a system overview of this system via a data flow like diagram.\n- [ ] This rendering system should be so simple, that a minimal implementation might as well be\nwritten in bash.\nProvide an simple example implementation\n- [ ] Rendering pipeline should be functional/side effect free.\n- [ ] Combine standard website with network's blog.\n\nPlugin system based on dependency injection:\n```\nrenderer[i] -\u003e output[i] // How to chain renderers?\noutput[1...n] -\u003e merge -\u003e output-2\n```","files":null},{"type":6,"author":{"id":"37314acb12deef6cac38223490bc1b720908d897"},"timestamp":1634931760,"metadata":{"github-id":"UCE_lAHOFCNQW84x4IfKziWdET4"},"target":"74032b06e4c3d7eaf8e3063f522b7e939d35ac3a180e904115b1d56235745ca3","message":"This has much in common the problem of `repo.process`.\nThere the problem is, that `repo.process` is too complicated(= not that easy to port),\nbecause there is no trivial way to get the list of all repos, without the command itself.\nYes it is easy, but it is not trivial.\nA trivial solution should be like parsing a CSV or at least similar.\n\nComing back to the problem at hand.\nWe need a simply model, how the website server works.\n\n- [x] Thereby, the objectives need to be updated.\n- [x] Create a dedicated project defining a standard for supporting arbitrary renderers. -\u003e `net.splitcells.website.server.interface`\n- [x] Define layered plugin based rendering system based on shell and file system as universal interface,\nthat model a rendering pipeline.\n- [ ] Make a system overview of this system via a data flow like diagram.\n- [ ] This rendering system should be so simple, that a minimal implementation might as well be\nwritten in bash.\nProvide an simple example implementation\n- [ ] Rendering pipeline should be functional/side effect free.\n- [ ] Combine standard website with network's blog.\n- [ ] Blog about new project build command.\n\nPlugin system based on dependency injection:\n```\nrenderer[i] -\u003e output[i] // How to chain renderers?\noutput[1...n] -\u003e merge -\u003e output-2\n```","files":null},{"type":6,"author":{"id":"37314acb12deef6cac38223490bc1b720908d897"},"timestamp":1635111694,"metadata":{"github-id":"UCE_lAHOFCNQW84x4IfKziWkk7g"},"target":"74032b06e4c3d7eaf8e3063f522b7e939d35ac3a180e904115b1d56235745ca3","message":"This has much in common the problem of `repo.process`.\nThere the problem is, that `repo.process` is too complicated(= not that easy to port),\nbecause there is no trivial way to get the list of all repos, without the command itself.\nYes it is easy, but it is not trivial.\nA trivial solution should be like parsing a CSV or at least similar.\n\nComing back to the problem at hand.\nWe need a simply model, how the website server works.\n\n- [x] Thereby, the objectives need to be updated.\n- [x] Create a dedicated project defining a standard for supporting arbitrary renderers. -\u003e `net.splitcells.website.server.interface`\n- [x] Define layered plugin based rendering system based on shell and file system as universal interface,\nthat model a rendering pipeline.\n- [ ] Make a system overview of this system via a data flow like diagram.\n- [ ] This rendering system should be so simple, that a minimal implementation might as well be\nwritten in bash.\nProvide an simple example implementation\n- [x] Rendering pipeline should be functional/side effect free.\n- [ ] Combine standard website with network's blog.\n- [ ] Blog about new project build command.\n\nPlugin system based on dependency injection:\n```\nrenderer[i] -\u003e output[i] // How to chain renderers?\noutput[1...n] -\u003e merge -\u003e output-2\n```","files":null},{"type":6,"author":{"id":"37314acb12deef6cac38223490bc1b720908d897"},"timestamp":1635116653,"metadata":{"github-id":"UCE_lAHOFCNQW84x4IfKziWkwYc"},"target":"74032b06e4c3d7eaf8e3063f522b7e939d35ac3a180e904115b1d56235745ca3","message":"This has much in common the problem of `repo.process`.\nThere the problem is, that `repo.process` is too complicated(= not that easy to port),\nbecause there is no trivial way to get the list of all repos, without the command itself.\nYes it is easy, but it is not trivial.\nA trivial solution should be like parsing a CSV or at least similar.\n\nComing back to the problem at hand.\nWe need a simply model, how the website server works.\n\n- [x] Thereby, the objectives need to be updated.\n- [x] Create a dedicated project defining a standard for supporting arbitrary renderers. -\u003e `net.splitcells.website.server.interface`\n- [x] Define layered plugin based rendering system based on shell and file system as universal interface,\nthat model a rendering pipeline.\n- [x] Make a system overview of this system via a data flow like diagram.\n- [ ] This rendering system should be so simple, that a minimal implementation might as well be\nwritten in bash.\nProvide an simple example implementation\n- [x] Rendering pipeline should be functional/side effect free.\n- [ ] Combine standard website with network's blog.\n- [ ] Blog about new project build command.\n\nPlugin system based on dependency injection:\n```\nrenderer[i] -\u003e output[i] // How to chain renderers?\noutput[1...n] -\u003e merge -\u003e output-2\n```","files":null},{"type":6,"author":{"id":"37314acb12deef6cac38223490bc1b720908d897"},"timestamp":1635553929,"metadata":{"github-id":"UCE_lAHOFCNQW84x4IfKziXibJg"},"target":"74032b06e4c3d7eaf8e3063f522b7e939d35ac3a180e904115b1d56235745ca3","message":"This has much in common the problem of `repo.process`.\nThere the problem is, that `repo.process` is too complicated(= not that easy to port),\nbecause there is no trivial way to get the list of all repos, without the command itself.\nYes it is easy, but it is not trivial.\nA trivial solution should be like parsing a CSV or at least similar.\n\nComing back to the problem at hand.\nWe need a simply model, how the website server works.\n\n- [x] Thereby, the objectives need to be updated.\n- [x] Create a dedicated project defining a standard for supporting arbitrary renderers. -\u003e `net.splitcells.website.server.interface`\n- [x] Define layered plugin based rendering system based on shell and file system as universal interface,\nthat model a rendering pipeline.\n- [x] Make a system overview of this system via a data flow like diagram.\n- [ ] This rendering system should be so simple, that a minimal implementation might as well be\nwritten in bash.\nProvide an simple example implementation\n- [x] Rendering pipeline should be functional/side effect free.\n- [ ] Blog about new project build command.\n- [ ] Create implementation based on project commands.\nThis defines a pattern in order to combine projects via project commands.\nThis would be used for website rendering via hugo and website server.\n\nPlugin system based on dependency injection:\n```\nrenderer[i] -\u003e output[i] // How to chain renderers?\noutput[1...n] -\u003e merge -\u003e output-2\n```","files":null},{"type":6,"author":{"id":"37314acb12deef6cac38223490bc1b720908d897"},"timestamp":1636321796,"metadata":{"github-id":"UCE_lAHOFCNQW84x4IfKziYqzuY"},"target":"74032b06e4c3d7eaf8e3063f522b7e939d35ac3a180e904115b1d56235745ca3","message":"This has much in common the problem of `repo.process`.\nThere the problem is, that `repo.process` is too complicated(= not that easy to port),\nbecause there is no trivial way to get the list of all repos, without the command itself.\nYes it is easy, but it is not trivial.\nA trivial solution should be like parsing a CSV or at least similar.\n\nComing back to the problem at hand.\nWe need a simply model, how the website server works.\n\n- [x] Thereby, the objectives need to be updated.\n- [x] Create a dedicated project defining a standard for supporting arbitrary renderers. -\u003e `net.splitcells.website.server.interface`\n- [x] Define layered plugin based rendering system based on shell and file system as universal interface,\nthat model a rendering pipeline.\n- [x] Make a system overview of this system via a data flow like diagram.\n- [x] This rendering system should be so simple, that a minimal implementation might as well be\nwritten in bash.\nProvide an simple example implementation\n- [x] Rendering pipeline should be functional/side effect free.\n- [ ] Blog about new project build command.\n- [ ] Create implementation based on project commands.\nThis defines a pattern in order to combine projects via project commands.\nThis would be used for website rendering via hugo and website server.\n\nPlugin system based on dependency injection:\n```\nrenderer[i] -\u003e output[i] // How to chain renderers?\noutput[1...n] -\u003e merge -\u003e output-2\n```","files":null},{"type":6,"author":{"id":"37314acb12deef6cac38223490bc1b720908d897"},"timestamp":1636323863,"metadata":{"github-id":"UCE_lAHOFCNQW84x4IfKziYq5OU"},"target":"74032b06e4c3d7eaf8e3063f522b7e939d35ac3a180e904115b1d56235745ca3","message":"This has much in common the problem of `repo.process`.\nThere the problem is, that `repo.process` is too complicated(= not that easy to port),\nbecause there is no trivial way to get the list of all repos, without the command itself.\nYes it is easy, but it is not trivial.\nA trivial solution should be like parsing a CSV or at least similar.\n\nComing back to the problem at hand.\nWe need a simply model, how the website server works.\n\n- [x] Thereby, the objectives need to be updated.\n- [x] Create a dedicated project defining a standard for supporting arbitrary renderers. -\u003e `net.splitcells.website.server.interface`\n- [x] Define layered plugin based rendering system based on shell and file system as universal interface,\nthat model a rendering pipeline.\n- [x] Make a system overview of this system via a data flow like diagram.\n- [x] This rendering system should be so simple, that a minimal implementation might as well be\nwritten in bash.\nProvide an simple example implementation\n- [x] Rendering pipeline should be functional/side effect free.\n- [ ] Blog about new project build command.\n- [x] Create implementation based on project commands.\nThis defines a pattern in order to combine projects via project commands.\nThis would be used for website rendering via hugo and website server.\n\nPlugin system based on dependency injection:\n```\nrenderer[i] -\u003e output[i] // How to chain renderers?\noutput[1...n] -\u003e merge -\u003e output-2\n```","files":null},{"type":6,"author":{"id":"37314acb12deef6cac38223490bc1b720908d897"},"timestamp":1636323891,"metadata":{"github-id":"UCE_lAHOFCNQW84x4IfKziYq5R4"},"target":"74032b06e4c3d7eaf8e3063f522b7e939d35ac3a180e904115b1d56235745ca3","message":"This has much in common the problem of `repo.process`.\nThere the problem is, that `repo.process` is too complicated(= not that easy to port),\nbecause there is no trivial way to get the list of all repos, without the command itself.\nYes it is easy, but it is not trivial.\nA trivial solution should be like parsing a CSV or at least similar.\n\nComing back to the problem at hand.\nWe need a simply model, how the website server works.\n\n- [x] Thereby, the objectives need to be updated.\n- [x] Create a dedicated project defining a standard for supporting arbitrary renderers. -\u003e `net.splitcells.website.server.interface`\n- [x] Define layered plugin based rendering system based on shell and file system as universal interface,\nthat model a rendering pipeline.\n- [x] Make a system overview of this system via a data flow like diagram.\n- [x] This rendering system should be so simple, that a minimal implementation might as well be\nwritten in bash.\nProvide an simple example implementation\n- [x] Rendering pipeline should be functional/side effect free.\n- [ ] Blog about new project build command.\n- [x] Create implementation based on project commands.\nThis defines a pattern in order to combine projects via project commands.\nThis would be used for website rendering via hugo and website server. -\u003e This is done via `project.render.as.net.splitcells.website`.\n\nPlugin system based on dependency injection:\n```\nrenderer[i] -\u003e output[i] // How to chain renderers?\noutput[1...n] -\u003e merge -\u003e output-2\n```","files":null},{"type":6,"author":{"id":"37314acb12deef6cac38223490bc1b720908d897"},"timestamp":1638065800,"metadata":{"github-id":"UCE_lAHOFCNQW84x4IfKzibuziI"},"target":"74032b06e4c3d7eaf8e3063f522b7e939d35ac3a180e904115b1d56235745ca3","message":"This has much in common the problem of `repo.process`.\nThere the problem is, that `repo.process` is too complicated(= not that easy to port),\nbecause there is no trivial way to get the list of all repos, without the command itself.\nYes it is easy, but it is not trivial.\nA trivial solution should be like parsing a CSV or at least similar.\n\nComing back to the problem at hand.\nWe need a simply model, how the website server works.\n\n- [x] Thereby, the objectives need to be updated.\n- [x] Create a dedicated project defining a standard for supporting arbitrary renderers. -\u003e `net.splitcells.website.server.interface`\n- [x] Define layered plugin based rendering system based on shell and file system as universal interface,\nthat model a rendering pipeline.\n- [x] Make a system overview of this system via a data flow like diagram.\n- [x] This rendering system should be so simple, that a minimal implementation might as well be\nwritten in bash.\nProvide an simple example implementation\n- [x] Rendering pipeline should be functional/side effect free.\n- [x] Blog about new project build command.\n- [x] Create implementation based on project commands.\nThis defines a pattern in order to combine projects via project commands.\nThis would be used for website rendering via hugo and website server. -\u003e This is done via `project.render.as.net.splitcells.website`.\n\nPlugin system based on dependency injection:\n```\nrenderer[i] -\u003e output[i] // How to chain renderers?\noutput[1...n] -\u003e merge -\u003e output-2\n```","files":null},{"type":6,"author":{"id":"37314acb12deef6cac38223490bc1b720908d897"},"timestamp":1638702305,"metadata":{"github-id":"UCE_lAHOFCNQW84x4IfKzic3_qY"},"target":"74032b06e4c3d7eaf8e3063f522b7e939d35ac3a180e904115b1d56235745ca3","message":"This has much in common the problem of `repo.process`.\nThere the problem is, that `repo.process` is too complicated(= not that easy to port),\nbecause there is no trivial way to get the list of all repos, without the command itself.\nYes it is easy, but it is not trivial.\nA trivial solution should be like parsing a CSV or at least similar.\n\nComing back to the problem at hand.\nWe need a simply model, how the website server works.\n\n- [x] Thereby, the objectives need to be updated.\n- [x] Create a dedicated project defining a standard for supporting arbitrary renderers. -\u003e `net.splitcells.website.server.interface`\n- [x] Define layered plugin based rendering system based on shell and file system as universal interface,\nthat model a rendering pipeline.\n- [x] Make a system overview of this system via a data flow like diagram.\n- [x] This rendering system should be so simple, that a minimal implementation might as well be\nwritten in bash.\nProvide an simple example implementation\n- [x] Rendering pipeline should be functional/side effect free.\n- [X] Blog about new project build command. -\u003e https://splitcells-net.srht.site/blog/2021-11-27-supporting-arbitrary-website-renderes/\n- [x] Create implementation based on project commands.\nThis defines a pattern in order to combine projects via project commands.\nThis would be used for website rendering via hugo and website server. -\u003e This is done via `project.render.as.net.splitcells.website`.\n\nPlugin system based on dependency injection:\n```\nrenderer[i] -\u003e output[i] // How to chain renderers?\noutput[1...n] -\u003e merge -\u003e output-2\n```","files":null},{"type":2,"author":{"id":"37314acb12deef6cac38223490bc1b720908d897"},"timestamp":1616376653,"metadata":{"github-id":"MDE3OlJlbmFtZWRUaXRsZUV2ZW50NDQ4NzQ5MzY3MA=="},"title":"Support arbitrary renderers for website server.","was":"Support arbitrary renderers for website server."},{"type":4,"author":{"id":"37314acb12deef6cac38223490bc1b720908d897"},"timestamp":1638066248,"metadata":{"github-id":"CE_lADOFCNQW84x4IfKzwAAAAFSl_iR"},"status":2}]}