<?xml version="1.0" encoding="UTF-8"?>
<article xmlns="http://splitcells.net/sew.xsd" xmlns:d="http://splitcells.net/den.xsd">
    <meta>
        <!--
            SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-or-later
            SPDX-FileCopyrightText: Contributors To The `net.splitcells.*` Projects
        -->
        <title>Inherently Broken and Rotten by Design</title>
    </meta>
    <chapter>
        <title>Reason for These Guidelines</title>
        <paragraph>It's hard to get things right on the first try and to be honest on the second, third and so on.
            There is the inherit problem,
            that as humans we are not able to somewhat reliably determine as a group,
            if something is correct or better than something else,
            according to a given knowledge base.
            On average, we are not even able to determine, the best person for a job.
            Instead of living in denial, this is an attempt to cope with this situation.
        </paragraph>
    </chapter>
    <chapter>
        <title>Broken by Design</title>
        <paragraph>So, it is assumed, that core decisions regarding the software architecture and
            features will be done incorrectly.
            The main target is to minimize the damage done by incorrect decisions or
            human errors during their implementations.
        </paragraph>
        <paragraph>Delaying decisions or their implementation can minimize their caused damage by skipping
            obsolete actions or by improving their planning based on new information.
            The basic idea is, that most of the time some knowledge is missing,
            when a decision is being made.
            Delaying a decision or an implementation while using the software or developing different features,
            will provide additional useful info.
            This info can potentially be used, in order to improve the planning.
            Even programming parts that are not part of a decision, can provide insights.
        </paragraph>
        <paragraph>Therefore, a minimalistic implementation can be done first,
            that just barely meets the requirements and does not have any extras.
            By delaying the complete implementation as much as possible,
            the usage of the minimalistic implementation can provide more info regarding the features' usefulness and
            how a correct and full implementation would look like.
            In other words, technical debt can be build up,
            in order to finance a technical investment, that may lead to a development loss or profit.
        </paragraph>
        <paragraph>Let's assume, that your application needs an export of table data,
            so that a user can access it via a spreadsheet program like Excel.
            You could start implementing a proper export for Excel's XSLX file format,
            or you could start by implementing a CSV export.
            The CSV variant would be easier to implement, also the user would have to convert the CSV data.
        </paragraph>
        <paragraph>Of course, you would not implement a proper CSV export first, but a ghetto version.
            This version just joins together the values of lines via commas and lines via new line symbols,
            without regards for escaping special characters.
            After some time, you notice, that the user doesn't actually use Excel,
            but LibreOffice instead.
            Therefore, you scrap the plans for an XSLX export and build an ODS export for LibreOffice instead.
        </paragraph>
        <d:todo>Many more projects are started this way Migration based Development
            backward compatible development for internal and external components
            automatic refactoring avoids the need for backward compatible development
            lots of legacy code
            legacy code as profit margin
        </d:todo>
        <d:todo>architecture is considered a thing, that is not part of the source code and determines the overhaul structure.
            architecture is a source of errors with limited benefits as interfaces can model pseudo architectures on the
            fly as well
            consider every  module, package and source code file its own project and draft the interfaces and functionality accordingly
            this is pseudo architecture
            Minimize architecture.
        </d:todo>
        <paragraph>This approach creates an inherently broken design,
            as decisions are delayed or incomplete as much as possible.
            Every delayed or incomplete decision breaks the contract in some way with requirements of the software.
            Things like a complete overarching software architecture or explicit requirement engineering
            are avoided as long as there is no concrete need for it.
            Therefore, big, deep and fundamental adaptations may need to be done at any moment without any warning,
            as decisions are revisioned.
            It is expected that the positives of the technical debt outweigh the negatives.
            The minimization and containment of the adaptation costs by using migration based development for example
            is one of the highest priorities, as otherwise these costs will kill the project.
        </paragraph>
    </chapter>
    <chapter>
        <title>Rotten by Design</title>
        <d:todo>All non-conflicting feature requests, that are financed, are accepted.</d:todo>
        <d:todo>Embrace the Explosion of Complexity of the whole and minimize the complexity of small components.
            Migration based Development
        </d:todo>
        <d:todo>Only developers decided the features, that are implemented. Project leader etc. only can request.
        </d:todo>
    </chapter>
    <chapter>
        <title>Finishing The Package</title>
        <d:todo>Tension based stability</d:todo>
        <d:todo>Security through hostile environments</d:todo>
        <d:todo>Edge of chaos</d:todo>
    </chapter>
</article>
