<?xml version="1.0" encoding="UTF-8"?>
<article xmlns="http://splitcells.net/sew.xsd" xmlns:d="http://splitcells.net/den.xsd">
    <meta>
        <!--
            SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-or-later
            SPDX-FileCopyrightText: Contributors To The `net.splitcells.*` Projects
        -->
        <title>Inherently Broken and Rotten by Design</title>
    </meta>
    <chapter>
        <title>Reason for These Guidelines</title>
        <paragraph>It's hard to get things right on the first try and to be honest on the second, third and so on.
            There is the inherit problem,
            that as humans we are not able to somewhat reliably determine as a group,
            if something is correct or better than something else,
            according to a given knowledge base.
            On average, we are not even able to determine, the best person for a job.
            Instead of living in denial, this is an attempt to cope with this situation.
        </paragraph>
    </chapter>
    <chapter>
        <title>Broken by Design</title>
        <paragraph>So, it is assumed, that core decisions regarding the software architecture and
            features will be done incorrectly.
            The main target is to minimize the damage done by incorrect decisions or
            human errors during their implementations.
        </paragraph>
        <paragraph>Delaying decisions or their implementation can minimize their caused damage by skipping
            obsolete actions or by improving their planning based on new information.
            The basic idea is, that most of the time some knowledge is missing,
            when a decision is being made.
            Delaying a decision or an implementation while using the software or developing different features,
            will provide additional useful info.
            This info can potentially be used, in order to improve the planning.
            Even programming parts that are not part of a decision, can provide insights.
        </paragraph>
        <paragraph>Therefore, a minimalistic implementation can be done first,
            that just barely meets the requirements and does not have any extras.
            By delaying the complete implementation as much as possible,
            the usage of the minimalistic implementation can provide more info regarding the features' usefulness and
            how a correct and full implementation would look like.
            In other words, technical debt can be build up,
            in order to finance a technical investment, that may lead to a development loss or profit.
        </paragraph>
        <paragraph>Let's assume, that your application needs an export of table data,
            so that a user can access it via a spreadsheet program like Excel.
            You could start implementing a proper export for Excel's XSLX file format,
            or you could start by implementing a CSV export.
            The CSV variant would be easier to implement, also the user would have to convert the CSV data.
        </paragraph>
        <paragraph>Of course, you would not implement a proper CSV export first, but a ghetto version.
            This version just joins together the values of lines via commas and lines via new line symbols,
            without regards for escaping special characters.
            After some time, you notice, that the user doesn't actually use Excel,
            but LibreOffice instead.
            Therefore, you scrap the plans for an XSLX export and build an ODS export for LibreOffice instead.
        </paragraph>
        <d:todo>Many more projects are started this way Migration based Development</d:todo>
        <d:todo>architecture is a source of errors with limited benefits as interfaces can model architectures on the
            fly as well
            Minimize architecture.
        </d:todo>
    </chapter>
    <chapter>
        <title>Rotten by Design</title>
        <d:todo>All feature requests are accepted.</d:todo>
        <d:todo>Bad or no memory and performance optimization</d:todo>
        <d:todo>Explosion of Complexity</d:todo>
        <d:todo>Only developers decided the features, that are implemented. Project leader etc. only can request.</d:todo>
        <d:todo>Security</d:todo>
    </chapter>
    <chapter>
        <title>Finishing The Package</title>
        <d:todo>Tension based stability</d:todo>
        <d:todo>Positive dividends of technical debts by skipping migrations</d:todo>
        <d:todo>Fitting developers</d:todo>
    </chapter>
</article>
