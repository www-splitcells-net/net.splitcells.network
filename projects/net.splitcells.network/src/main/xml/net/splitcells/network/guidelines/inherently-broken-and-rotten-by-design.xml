<?xml version="1.0" encoding="UTF-8"?>
<article xmlns="http://splitcells.net/sew.xsd" xmlns:d="http://splitcells.net/den.xsd">
    <meta>
        <!--
            SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-or-later
            SPDX-FileCopyrightText: Contributors To The `net.splitcells.*` Projects
        -->
        <title>Inherently Broken and Rotten by Design</title>
    </meta>
    <chapter>
        <title>Reason for These Guidelines</title>
        <paragraph>It's hard to get things right on the first try and to be honest on the second, third and so on.
            There is the inherit problem,
            that as humans we are not able to somewhat reliably determine as a group,
            if something is correct or better than something else,
            according to a given knowledge base.
            On average, we are not even able to determine, the best person for a job.
            Instead of living in denial, this is an attempt to cope with this situation.
        </paragraph>
    </chapter>
    <chapter>
        <title>Broken by Design</title>
        <paragraph>So, it is assumed, that core decisions regarding the software architecture and
            features will be done incorrectly.
            The main target is to minimize the damage done by incorrect decisions or
            human errors during their implementations.
        </paragraph>
        <paragraph>Delaying decisions or their implementation can minimize their caused damage by skipping
            obsolete actions or by improving their planning based on new information.
            The basic idea is, that most of the time some knowledge is missing,
            when a decision is being made.
            Delaying a decision or an implementation while using the software or developing different features,
            will provide additional useful info.
            This info can potentially be used, in order to improve the planning.
            Even programming parts that are not part of a decision, can provide insights.
        </paragraph>
        <paragraph>Therefore, a minimalistic implementation can be done first,
            that just barely meets the requirements and does not have any extras.
            By delaying the complete implementation as much as possible,
            the usage of the minimalistic implementation can provide more info regarding the features' usefulness and
            how a correct and full implementation would look like.
            In other words, technical debt can be build up,
            in order to finance a technical investment, that may lead to a development loss or profit.
        </paragraph>
        <d:todo>Example</d:todo>
        <d:todo>Migration based Development</d:todo>
        <d:todo>Minimize architecture.</d:todo>
    </chapter>
    <chapter>
        <title>Rotten by Design</title>
        <d:todo>All feature requests are accepted.</d:todo>
        <d:todo>Bad or no memory and performance optimization</d:todo>
        <d:todo>Explosion of Complexity</d:todo>
        <d:todo>Only developers decided the features, that are implemented. Project leader etc. only can request.</d:todo>
        <d:todo>Security</d:todo>
    </chapter>
    <chapter>
        <title>Finishing The Package</title>
        <d:todo>Tension based stability</d:todo>
        <d:todo>Positive dividends of technical debts by skipping migrations</d:todo>
        <d:todo>Fitting developers</d:todo>
    </chapter>
</article>