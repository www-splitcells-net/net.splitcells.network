#!/usr/bin/env python3
"""
SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-or-later
SPDX-FileCopyrightText: Contributors To The `net.splitcells.*` Projects

TODO Use string's substitute method, instead of string's replace.
TODO Support deployment to Docker and Kubernetes.
TODO Support executing as systemd service. Create a user service for that.
"""

__author__ = "Mārtiņš Avots"
__authors__ = ["Contributors To The `net.splitcells.*` Projects"]
__copyright__ = "Copyright 2024"
__license__ = "EPL-2.0 OR GPL-2.0-or-later"

import argparse
import logging
import os
import platform
import shutil
import subprocess

dockerFileServiceTemplate = """FROM docker.io/eclipse-temurin:21-jdk-noble
RUN apt clean
RUN apt update # This fixes install errors. It is unknown why this is the case.
RUN apt install --yes maven git python3 pip
RUN pip install --break-system-packages playwright
RUN playwright install --with-deps firefox # Install all OS dependencies, that are required for Playwright. Otherwise, Playwright cannot be used in Java.
VOLUME /root/.local/state/
VOLUME /root/Documents/
VOLUME /root/.ssh/
VOLUME /root/.m2/
"""

javaClassExecutionTemplate = """COPY deployable-jars/* /root/.local/lib/$NAME_FOR_EXECUTION/jars/
WORKDIR /root/.local/lib/$NAME_FOR_EXECUTION/
ENTRYPOINT ["/opt/java/openjdk/bin/java"]
CMD ["-cp", "./jars/*", "$CLASS_FOR_EXECUTION"]
"""
# TODO executeViaPodman
prepareExecution = """set -e
set -x
executionName="$executionName"
executionCommand="$executionCommand"
# Prepare file system.
mkdir -p $HOME/.local/state/$executionName/.m2/
mkdir -p $HOME/.local/state/$executionName/.ssh/
mkdir -p $HOME/.local/state/$executionName/.local/
mkdir -p $HOME/.local/state/$executionName/Documents/
mkdir -p ./target/
test -f target/program-$executionName && chmod +x target/program-$executionName # This file does not exist, when '--executable-path' is not set.
podman build -f "target/Dockerfile-$executionName" \\
    --tag "localhost/$executionName"  \\
    --arch string \\
    --log-level=debug
    # Logging is used, in order to better understand build runtime performance.
"""
executeViaPodman = """
podman run --name "$executionName" \\
  --network slirp4netns:allow_host_loopback=true \\
  --rm \\
  -v $HOME/.local/state/$executionName/Documents:/root/Documents \\
  -v $HOME/.local/state/$executionName/.ssh:/root/.ssh \\
  -v $HOME/.local/state/$executionName/.m2:/root/.m2 \\
  -v $HOME/.local/state/$executionName/.local:/root/.local/state \\
  "$podmanParameters" \\
  "localhost/$executionName"
  #
  # allow_host_loopback is required, so that the software in the container can connect to the host.
"""
publishViaPodman = """
podman tag $executionName:latest codeberg.org/splitcells-net/$executionName:latest
podman push codeberg.org/splitcells-net/$executionName:latest
"""
cleanUpExecution = """
rm -f "target/Dockerfile-$executionName" # `-f` is used, in case the target folder is deleted via `mvn clean install` in `--command`.
"""
def str2bool(arg):
    return arg == 'true'
if __name__ == '__main__':
    parser = argparse.ArgumentParser(description="Executes a given program as isolated as possible with all program files being persisted at `$HOME/.local/state/$executionName/` and user input being located at `$HOME/Documents`." \
            + " Executions with different names have different persisted file locations and are therefore isolated more clearly, whereas executions with the same name are assumed to share data." \
            + " This is the CLI interface to the Splitcells Network Worker.")
    parser.add_argument('--name', dest='name', required=True, help="This is the name of the task being executed.")
    parser.add_argument('--command', dest='command'
                        , help="This is the shell command, to execute the task."
                               + "It consists of only one program call."
                               + " If scripts need to be executed one can use `sh -c \"[script]\"`."
                               + " Use this only, in order to integrate the environment with the software."
                               + " Prefer `--class-for-execution` instead.")
    parser.add_argument('--executable-path', dest='executablePath', help="Executes the given executable file. Only set this option or --command.")
    parser.add_argument('--class-for-execution', dest='classForExecution', help="This Java class is executed.")
    parser.add_argument('--use-host-documents', dest='useHostDocuments', required=False, type=str2bool, default=False, help="Determines whether to mount `~/Documents` or not. This should be avoided, in order to avoid file dependencies to the host system, which makes the execution more portable.")
    parser.add_argument('--publish-execution-image', dest='publishExecutionImage', required=False, type=str2bool, default=False, help="If set to true, the given command is not executed, but a container image is published instead.")
    parser.add_argument('--verbose', dest='publishExecutionImage', required=False, type=str2bool, default=False, help="If set to true, the output is verbose.")
    parser.add_argument('--only-build-image', dest='onlyBuildImage', required=False, type=str2bool, default=False, help="If set to true, the created image is not executed.")
    parser.add_argument('--cpu-architecture', dest='cpuArchitecture', help="Set the cpu architecture for the execution.")
    parser.add_argument('--auto-configure-cpu-architecture-explicitly', dest='autoConfigureCpuArchExplicitly', required=False, type=str2bool, default=False
            , help="If set to false, the command's backend automatically determines the CPU architecture." \
                + " If set to true, the CPU architecture will be determined by this command and the determined architecture is propagated to the commands backend explicitly." \
                + " This is useful, because some tools have not a good CPU auto detection (i.e. Podman on RISC-V cannot find the fitting images based on the CPU arch automatically).")
    parser.add_argument('--port-publishing', dest='portPublishing', help="This is a comma separated list of `host-port:container-port`, that describes the port forwarding on the host.")
    parsedArgs = parser.parse_args()
    if not os.path.exists('./target'):
        os.mkdir('./target')
    # Create Dockerfile.
    dockerfile = dockerFileServiceTemplate
    if parsedArgs.command is not None:
        dockerfile += 'ENTRYPOINT ' + parsedArgs.command
    elif parsedArgs.executablePath is not None:
        programName = "program-" + parsedArgs.name
        shutil.copyfile(parsedArgs.executablePath, "./target/" + programName)
        dockerfile += "ADD ./" + programName + " /root/program\n"
        dockerfile += 'ENTRYPOINT /root/program'
    elif parsedArgs.classForExecution is not None:
        dockerfile += (javaClassExecutionTemplate
            .replace('$NAME_FOR_EXECUTION', parsedArgs.name)
            .replace('$CLASS_FOR_EXECUTION', parsedArgs.classForExecution))
    else:
        raise Exception('Either `--command` or `--class-for-execution` needs to be set.')
    file='target/Dockerfile-' + parsedArgs.name
    with open(file, 'w') as filetowrite:
        filetowrite.write(dockerfile)
    # Create and execute script.
    executionScript = prepareExecution
    if parsedArgs.publishExecutionImage:
        executionScript += publishViaPodman
    elif parsedArgs.onlyBuildImage:
        pass
    else:
        executionScript += executeViaPodman
    executionScript += cleanUpExecution
    executionScript = executionScript.replace('"$executionName"', parsedArgs.name)
    if parsedArgs.command is not None:
        executionScript = executionScript.replace('"$executionCommand"', "'" + parsedArgs.command + "'")
    additionalPodmanArgs = ''
    if parsedArgs.portPublishing is not None:
        for portMapping in parsedArgs.portPublishing.split(','):
            additionalPodmanArgs += ' --publish ' + portMapping
    executionScript = executionScript.replace('"$podmanParameters"', additionalPodmanArgs)
    if parsedArgs.autoConfigureCpuArchExplicitly:
        executionScript = executionScript.replace('\n    --arch string \\\n', '\n    --arch ' + platform.uname().machine + ' \\\n')
    elif parsedArgs.cpuArchitecture is None:
        executionScript = executionScript.replace('\n    --arch string \\\n', '\\\n')
    else:
        executionScript = executionScript.replace('\n    --arch string \\\n', '\n    --arch ' + parsedArgs.cpuArchitecture + ' \\\n')
    if parsedArgs.useHostDocuments:
        # TODO This replacement is done in a dirty way. Use a template variable instead.
        print(executionScript)
        print("-v $HOME/.local/state/$executionName/Documents:/root/Documents \\")
        executionScript = executionScript.replace("-v $HOME/.local/state/$executionName/Documents:/root/Documents \\", "-v $HOME/Documents:/root/Documents \\")
    print(executionScript)
    # Execute program.
    returnCode = subprocess.call(executionScript, shell='True')
    if returnCode != 0:
        logging.error("Could not execute given command.");
    exit(returnCode)
